grammar<'input>;

use lexer::{Token, LexicalError};
use ast::{Op, Expr, Unary, Value, Stmt, Asgn, Name, Pat};

// Macros

// Simple macro for infix operator tiers
Tier<Op, NextTier>: Expr = {
    <l: Tier<Op, NextTier>> <op: Op> <r: NextTier> => Expr::BinOp(op, Box::new(l), Box::new(r)),
    NextTier
}

Comma<T>: Vec<T> = {
    <v: (<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
 }


pub Program: Vec<Stmt> = {
    <Statement*>
}

Statement: Stmt = {
    "let" <l: Identifier> "=" <r: LeftExpr> =>
        Stmt::Var(Asgn::Single(l), r),
    "return" <e: Expression> ";" => Stmt::Return(e),
    <l: Expression> ";" => Stmt::Expr(l),
    "if" <b: Expression> "{" <body: Statement*> "}" <els: OptElse?> => Stmt::If(b, body, els)
}


OptElse: Vec<Stmt> = {
    "else" <Block>,
    
}

LeftExpr: Expr = {
    Function,
    <Equality> ";"
}

Expression: Expr = {
    Function,
    CommaExpr,
}

Function: Expr = {
    "\\" <args: FunParams> "=>" <body: FunBody> =>
        Expr::Function(args, body),
}

Block: Vec<Stmt> = {
    "{" <stmts: Statement*> <expr: Expression?> "}" => {
        let mut stmts = stmts;
        if let Some(e) = expr {
            stmts.push(Stmt::Return(e));
        }
        stmts
    }
}


FunBody: Vec<Stmt> = {
    <Block>,
    "(" <e: Expression> ")" => vec![Stmt::Return(e)]
}

// Important distinction: params are the *variables* with function
// definition, args are the actual *values* that are passed with a
// function call
FunParams: Pat = {
    <Pattern>
}

CommaExpr: Expr = Tier<CommaOp, Equality>;


Equality: Expr = {
    <l:Comparison> "!=" <r:Comparison> =>
        Expr::BinOp(Op::BangEqual, Box::new(l), Box::new(r)),
    <l:Comparison> "==" <r:Comparison> =>
        Expr::BinOp(Op::EqualEqual, Box::new(l), Box::new(r)),
    Comparison
}


Comparison: Expr = {
    <l:Addition> ">" <r:Addition> =>
        Expr::BinOp(Op::Greater, Box::new(l), Box::new(r)),
    <l:Addition> ">="  <r:Addition> =>
        Expr::BinOp(Op::GreaterEqual, Box::new(l), Box::new(r)),
    <l:Addition> "<" <r:Addition> =>
        Expr::BinOp(Op::Less, Box::new(l), Box::new(r)),
    <l:Addition> "<="  <r:Addition> =>
        Expr::BinOp(Op::LessEqual, Box::new(l), Box::new(r)),
    Addition
}

CommaOp: Op = {
    "," => Op::Comma
}

AddOp: Op = {
    "+" => Op::Plus,
    "-" => Op::Minus
}

MultOp: Op = {
    "*" => Op::Times,
    "/" => Op::Div,
}

Addition: Expr = Tier<AddOp, Multiplication>;

Multiplication: Expr = Tier<MultOp, Unary>;

Unary: Expr = {
    "!" <u: Term> => Expr::UnaryOp(Unary::Bang, Box::new(u)),
    "-" <u: Term> => Expr::UnaryOp(Unary::Minus, Box::new(u)),
    Term
}

Term: Expr = {
    <n: Num> => Expr::Primary(Value::Num(n)),
    "true" => Expr::Primary(Value::Bool(true)),
    "false" => Expr::Primary(Value::Bool(false)),
    <id: Identifier> => Expr::Var(id),
    <id: Identifier> <args: FunArgs> => Expr::Call(id, Box::new(args)),
    "(" <Expression> ")"
};

Pattern: Pat = {
    "(" <pats: Comma<Pattern>> ")" => Pat::Tuple(pats),
    "{" <ids: Comma<Identifier>> "}" => Pat::Record(ids),
    <id: Identifier> => Pat::Id(id)
}

FunArgs: Expr = {
    "(" <Expression> ")"
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "+"        => Token::Plus,
        "-"        => Token::Minus,
        "*"        => Token::Times,
        "/"        => Token::Div,
        "("        => Token::LParen,
        ")"        => Token::RParen,
        "+="       => Token::PlusEqual,
        "-="       => Token::MinusEqual,
        "*="       => Token::TimesEqual,
        "/="       => Token::DivEqual,
        "!="       => Token::BangEqual,
        "=="       => Token::EqualEqual,
        ">"        => Token::Greater,
        ">="       => Token::GreaterEqual,
        "<"        => Token::Less,
        "<="       => Token::LessEqual,
        "!"        => Token::Bang,
        "true"     => Token::True,
        "false"    => Token::False,
        ";"        => Token::Semicolon,
        "let"      => Token::Let,
        "="        => Token::Equal,
        ","        => Token::Comma,
        "=>"       => Token::FatArrow,
        "\\"       => Token::Slash,
	"fun"      => Token::Fun,
        "return"   => Token::Return,
        "if"       => Token::If,
        "else"     => Token::Else,
        "{"        => Token::LBrace,
        "}"        => Token::RBrace,
        Num        => Token::Number(<f32>),
        Identifier => Token::Ident(<String>)
    }
}
