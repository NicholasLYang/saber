use lexer::{Token, LexicalError};
use ast::{Op, Expr, Unary, Value, Stmt, Asgn, Name};

grammar<'input>;

// Macros

// Simple macro for infix operator tiers
Tier<Op, NextTier>: Expr = {
    <l: Tier<Op, NextTier>> <op: Op> <r: NextTier> => Expr::BinOp(op, Box::new(l), Box::new(r)),
    NextTier
}

Comma<T>: Vec<T> = {
    <v: (<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


pub Program: Vec<Stmt> = {
    <Statement*>
}

Statement: Stmt = {
    "let" <l: Identifier> "=" <r: LeftExpr> =>
        Stmt::Var(Asgn::Single(l), r),
    "return" <e: Expression> ";" => Stmt::Return(e),
    <l: Expression> ";" => Stmt::Expr(l),
}

LeftExpr: Expr = {
    <Function>,
    <Expression> ";"
}

Expression: Expr = {
    Equality
}

Function: Expr = {
    "\\" <args: FunParams> "=>" <body: FunBody> =>
        Expr::Function(args, body),
}

FunBody: Vec<Stmt> = {
    "{" <Statement*> "}",
    "(" <e: Expression> ")" => vec![Stmt::Expr(e)]
}

// Important distinction: params are the *variables* with function
// definition, args are the actual *values* that are passed with a
// function call
FunParams: Vec<Name> = {
    "(" <Comma<Identifier>> ")",
    <id: Identifier> => vec![id]
}


Equality: Expr = {
    <l:Comparison> "!=" <r:Comparison> =>
        Expr::BinOp(Op::BangEqual, Box::new(l), Box::new(r)),
    <l:Comparison> "==" <r:Comparison> =>
        Expr::BinOp(Op::EqualEqual, Box::new(l), Box::new(r)),
    Comparison
}


Comparison: Expr = {
    <l:Addition> ">" <r:Addition> =>
        Expr::BinOp(Op::Greater, Box::new(l), Box::new(r)),
    <l:Addition> ">="  <r:Addition> =>
        Expr::BinOp(Op::GreaterEqual, Box::new(l), Box::new(r)),
    <l:Addition> "<" <r:Addition> =>
        Expr::BinOp(Op::Less, Box::new(l), Box::new(r)),
    <l:Addition> "<="  <r:Addition> =>
        Expr::BinOp(Op::LessEqual, Box::new(l), Box::new(r)),
    Addition
}


AddOp: Op = {
    "+" => Op::Plus,
    "-" => Op::Minus
}

MultOp: Op = {
    "*" => Op::Times,
    "/" => Op::Div,
}

Addition = Tier<AddOp, Multiplication>;

Multiplication: Expr = Tier<MultOp, Unary>;

Unary: Expr = {
    "!" <u: Term> => Expr::UnaryOp(Unary::Bang, Box::new(u)),
    "-" <u: Term> => Expr::UnaryOp(Unary::Minus, Box::new(u)),
    Term
}

Term: Expr = {
    <n: Num> => Expr::Primary(Value::Num(n)),
    "true" => Expr::Primary(Value::Bool(true)),
    "false" => Expr::Primary(Value::Bool(false)),
    <id: Identifier> => Expr::Var(id),
    <id: Identifier> <args: FunArgs> => Expr::Call(id, args),
    "(" <Expression> ")"
};

FunArgs: Vec<Expr> = {
    "(" <Comma<Expression>> ")",
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "+"        => Token::Plus,
        "-"        => Token::Minus,
        "*"        => Token::Times,
        "/"        => Token::Div,
        "("        => Token::LParen,
        ")"        => Token::RParen,
        "+="       => Token::PlusEqual,
        "-="       => Token::MinusEqual,
        "*="       => Token::TimesEqual,
        "/="       => Token::DivEqual,
        "!="       => Token::BangEqual,
        "=="       => Token::EqualEqual,
        ">"        => Token::Greater,
        ">="       => Token::GreaterEqual,
        "<"        => Token::Less,
        "<="       => Token::LessEqual,
        "!"        => Token::Bang,
        "true"     => Token::True,
        "false"    => Token::False,
        ";"        => Token::Semicolon,
        "let"      => Token::Let,
        "="        => Token::Equal,
        ","        => Token::Comma,
        "=>"       => Token::FatArrow,
        "\\"       => Token::Slash,
	"fun"      => Token::Fun,
        "return"   => Token::Return,
        "{"        => Token::LBrace,
        "}"        => Token::RBrace,
        Num        => Token::Number(<f32>),
        Identifier => Token::Ident(<String>)
    }
}
