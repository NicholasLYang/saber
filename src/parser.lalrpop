grammar<'input>;

use lexer::{Token, LexicalError};
use ast::{Op, Expr, Unary, Value, Stmt, Pat, Type};

// Macros

// Simple macro for infix operator tiers
Tier<Op, NextTier>: Expr = {
    <l: Tier<Op, NextTier>> <op: Op> <r: NextTier> =>
        Expr::BinOp { op, lhs: Box::new(l), rhs: Box::new(r) },
    NextTier
}

Comma<T>: Vec<T> = {
    <v: (<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
 }


pub Program: Vec<Stmt> = {
    <Statement*>
}

Statement: Stmt = {
    "let" <l: Pattern> "=" <r: RightExpr> =>
        Stmt::Var(l, r),
    "return" <e: Expression> ";" => Stmt::Return(e),
    <l: Expression> ";" => Stmt::Expr(l),
    "if" <b: Expression> "{" <body: Statement*> "}" <els: OptElse?> => Stmt::If(b, body, els)
}


OptElse: Vec<Stmt> = {
    "else" <Block>,
    
}

RightExpr: Expr = {
    Function,
    <Equality> ";"
}

Expression: Expr = {
    Function,
    CommaExpr,
}

Function: Expr = {
    "\\" <params: FunParams> "=>" <body: FunBody> =>
        Expr::Function{ params, body },
}

Block: Vec<Stmt> = {
    "{" <stmts: Statement*> <expr: Expression?> "}" => {
        let mut stmts = stmts;
        if let Some(e) = expr {
            stmts.push(Stmt::Return(e));
        }
        stmts
    }
}


FunBody: Vec<Stmt> = {
    <Block>,
    "(" <e: Expression> ")" => vec![Stmt::Return(e)]
}

// Important distinction: params are the *variables* with function
// definition, args are the actual *values* that are passed with a
// function call
FunParams: Pat = {
    <Pattern>
}

CommaExpr: Expr = Tier<CommaOp, Equality>;


Equality: Expr = {
    <l:Comparison> "!=" <r:Comparison> =>
        Expr::BinOp { op: Op::BangEqual, lhs: Box::new(l), rhs: Box::new(r) },
    <l:Comparison> "==" <r:Comparison> =>
        Expr::BinOp{ op: Op::EqualEqual, lhs: Box::new(l), rhs: Box::new(r) },
    Comparison
}


Comparison: Expr = {
    <l:Addition> ">" <r:Addition> =>
        Expr::BinOp { op: Op::Greater, lhs: Box::new(l), rhs: Box::new(r) },
    <l:Addition> ">="  <r:Addition> =>
        Expr::BinOp { op: Op::GreaterEqual, lhs: Box::new(l), rhs: Box::new(r) },
    <l:Addition> "<" <r:Addition> =>
        Expr::BinOp { op: Op::Less, lhs: Box::new(l), rhs: Box::new(r) },
    <l:Addition> "<="  <r:Addition> =>
        Expr::BinOp { op: Op::LessEqual, lhs: Box::new(l), rhs: Box::new(r) },
    Addition
}

CommaOp: Op = {
    "," => Op::Comma
}

AddOp: Op = {
    "+" => Op::Plus,
    "-" => Op::Minus
}

MultOp: Op = {
    "*" => Op::Times,
    "/" => Op::Div,
}

Addition: Expr = Tier<AddOp, Multiplication>;

Multiplication: Expr = Tier<MultOp, Unary>;

Unary: Expr = {
    "!" <u: Term> => Expr::UnaryOp { unary: Unary::Bang, rhs: Box::new(u)},
    "-" <u: Term> => Expr::UnaryOp { unary: Unary::Minus, rhs: Box::new(u)},
    Term
}

Term: Expr = {
    <n: Num> => Expr::Primary { value: Value::Num(n) } ,
    "true" => Expr::Primary { value: Value::Bool(true) } ,
    "false" => Expr::Primary { value: Value::Bool(false) },
    <id: Identifier> => Expr::Var { name: id },
    <callee: Term> <args: FunArgs> =>
        Expr::Call { callee: Box::new(callee), arg: Box::new(args) },
    "(" <Expression> ")",
};

Pattern: Pat = {
    "(" <pats: Comma<Pattern>> ")" => Pat::Tuple(pats),
    "{" <ids: Comma<Identifier>> "}" => Pat::Record(ids),
    <id: Identifier> ":" <type_: TypeAnnotation> => Pat::Id(id, Some(type_)),
    <id: Identifier> => Pat::Id(id, None),
}

TypeAnnotation: Type = {
    "[" <type_: TypeAnnotation> "]" => Type::Vec(Box::new(type_)),
    <id: Identifier> => Type::Var(id),
    "(" <fst: TypeAnnotation> "," <snd: TypeAnnotation> ")" => {
       Type::Tuple(Box::new(fst), Box::new(snd))
    }
}

FunArgs: Expr = {
    "(" <Expression> ")"
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "+"        => Token::Plus,
        "-"        => Token::Minus,
        "*"        => Token::Times,
        "/"        => Token::Div,
        "("        => Token::LParen,
        ")"        => Token::RParen,
        "+="       => Token::PlusEqual,
        "-="       => Token::MinusEqual,
        "*="       => Token::TimesEqual,
        "/="       => Token::DivEqual,
        "!="       => Token::BangEqual,
        "=="       => Token::EqualEqual,
        ">"        => Token::Greater,
        ">="       => Token::GreaterEqual,
        "<"        => Token::Less,
        "<="       => Token::LessEqual,
        "!"        => Token::Bang,
        "true"     => Token::True,
        "false"    => Token::False,
        ";"        => Token::Semicolon,
        "let"      => Token::Let,
        "="        => Token::Equal,
        ","        => Token::Comma,
        "=>"       => Token::FatArrow,
        "\\"       => Token::Slash,
	"fun"      => Token::Fun,
        "return"   => Token::Return,
        "if"       => Token::If,
        "else"     => Token::Else,
        "{"        => Token::LBrace,
        "}"        => Token::RBrace,
        "["        => Token::LBracket,
        "]"        => Token::RBracket,
        ":"        => Token::Colon,
        Num        => Token::Number(<f32>),
        Identifier => Token::Ident(<String>)
    }
}
