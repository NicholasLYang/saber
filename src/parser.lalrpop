use lexer::{Token, LexicalError};
use ast::{Op, Expr, Unary, Value, Stmt, Asgn, Name};

grammar<'input>;

// Macros

// Simple macro for infix operator tiers
Tier<Op, NextTier>: Expr = {
    <l: Tier<Op, NextTier>> <op: Op> <r: NextTier> => Expr::BinOp(op, Box::new(l), Box::new(r)),
    NextTier
}

Comma<T>: Vec<T> = {
    <v: (<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


pub Program: Vec<Stmt> = {
    <Statement*>
}

pub Statement: Stmt = {
    "let" <l: Identifier> "=" <r: Expression> ";" =>
        Stmt::Var(Asgn::Single(l), r),
    <l: Expression> ";" => Stmt::Expr(l),
    <f: Function> => Stmt::Expr(f)
}

pub Expression: Expr = {
    Equality,
}

pub Function: Expr = {
    <args: FunArgs> ":=" <body: FunBody> =>
        Expr::Function(args, body)
}

FunBody: Vec<Stmt> = {
    <s: Statement> => vec![s],
    <e: Expression> => vec![Stmt::Expr(e)]
}

FunArgs: Vec<Name> = {
    "(" <ids: Comma<Identifier>> ")" => ids,
    <id: Identifier> => vec![id]
}


pub Equality: Expr = {
    <l:Comparison> "!=" <r:Comparison> =>
        Expr::BinOp(Op::BangEqual, Box::new(l), Box::new(r)),
    <l:Comparison> "==" <r:Comparison> =>
        Expr::BinOp(Op::EqualEqual, Box::new(l), Box::new(r)),
    Comparison
}


pub Comparison: Expr = {
    <l:Addition> ">" <r:Addition> =>
        Expr::BinOp(Op::Greater, Box::new(l), Box::new(r)),
    <l:Addition> ">="  <r:Addition> =>
        Expr::BinOp(Op::GreaterEqual, Box::new(l), Box::new(r)),
    <l:Addition> "<" <r:Addition> =>
        Expr::BinOp(Op::Less, Box::new(l), Box::new(r)),
    <l:Addition> "<="  <r:Addition> =>
        Expr::BinOp(Op::LessEqual, Box::new(l), Box::new(r)),
    Addition
}


AddOp: Op = {
    "+" => Op::Plus,
    "-" => Op::Minus
}

MultOp: Op = {
    "*" => Op::Times,
    "/" => Op::Div,
}

Addition = Tier<AddOp, Multiplication>;

Multiplication: Expr = Tier<MultOp, Unary>;

pub Unary: Expr = {
    "!" <u: Term> => Expr::UnaryOp(Unary::Bang, Box::new(u)),
    "-" <u: Term> => Expr::UnaryOp(Unary::Minus, Box::new(u)),
    Term
}

pub Term: Expr = {
    <n: Num> => Expr::Primary(Value::Num(n)),
    "true" => Expr::Primary(Value::Bool(true)),
    "false" => Expr::Primary(Value::Bool(false)),
    "(" <Expression> ")"
};

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "+"        => Token::Plus,
        "-"        => Token::Minus,
        "*"        => Token::Times,
        "/"        => Token::Div,
        "("        => Token::LParen,
        ")"        => Token::RParen,
        "+="       => Token::PlusEqual,
        "-="       => Token::MinusEqual,
        "*="       => Token::TimesEqual,
        "/="       => Token::DivEqual,
        "!="       => Token::BangEqual,
        "=="       => Token::EqualEqual,
        ">"        => Token::Greater,
        ">="       => Token::GreaterEqual,
        "<"        => Token::Less,
        "<="       => Token::LessEqual,
        "!"        => Token::Bang,
        "true"     => Token::True,
        "false"    => Token::False,
        ";"        => Token::Semicolon,
        "let"      => Token::Let,
        "="        => Token::Equal,
        ":="       => Token::ColonEqual,
        ","        => Token::Comma,
        Num        => Token::Number(<f32>),
        Identifier => Token::Ident(<String>)
    }
}
